Supercombinator definitions
Code for False
Code:{Pack (1,0)
      Update 0
      Pop 0
      Unwind}



Code for True
Code:{Pack (2,0)
      Update 0
      Pop 0
      Unwind}



Code for if
Code:{Push 0
      Eval
      Get
      Cond
        ([Push 1; Eval; Update 3; Pop 3; Unwind],
         [Push 2; Eval; Update 3; Pop 3; Unwind])}



Code for negate
Code:{Push 0
      Eval
      Get
      Neg
      UpdateInt 1
      Pop 1
      Unwind}



Code for |
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Or
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for &
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      And
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for >=
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Ge
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for >
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Gt
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for <=
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Le
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for <
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Lt
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for ~=
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Ne
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for ==
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Eq
      Mkbool
      Update 2
      Pop 2
      Unwind}



Code for /
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Div
      UpdateInt 2
      Pop 2
      Unwind}



Code for *
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Mul
      UpdateInt 2
      Pop 2
      Unwind}



Code for -
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Sub
      UpdateInt 2
      Pop 2
      Unwind}



Code for +
Code:{Push 1
      Eval
      Get
      Push 0
      Eval
      Get
      Add
      UpdateInt 2
      Pop 2
      Unwind}



Code for main
Code:{Pushint 2
      Update 0
      Pop 0
      Unwind}



Code for twice
Code:{Push 0
      Push 1
      Pushglobal "compose"
      Mkap
      Mkap
      Eval
      Update 1
      Pop 1
      Unwind}



Code for compose
Code:{Push 2
      Push 2
      Mkap
      Push 1
      Mkap
      Eval
      Update 3
      Pop 3
      Unwind}



Code for S
Code:{Push 2
      Push 2
      Mkap
      Push 3
      Push 2
      Mkap
      Mkap
      Eval
      Update 3
      Pop 3
      Unwind}



Code for K1
Code:{Push 1
      Eval
      Update 2
      Pop 2
      Unwind}



Code for K
Code:{Push 0
      Eval
      Update 2
      Pop 2
      Unwind}



Code for I
Code:{Push 0
      Eval
      Update 1
      Pop 1
      Unwind}




State transitions

   0) VStack:[]
      Stack:[]
      
      Dump:[]
      
      Code:{Pushglobal "main"
            Eval}
      
   1) VStack:[]
      Stack:[7: Global main]
      
      Dump:[]
      
      Code:{Eval}
      
   2) VStack:[]
      Stack:[7: Global main]
      
      Dump:[<{}, S:[], V:[]>]
      
      Code:{Unwind}
      
   3) VStack:[]
      Stack:[7: Global main]
      
      Dump:[<{}, S:[], V:[]>]
      
      Code:{Pushint 2
            Update 0
            Pop 0
            Unwind}
      
   4) VStack:[]
      Stack:[7: Global main
             24: 2]
      
      Dump:[<{}, S:[], V:[]>]
      
      Code:{Update 0
            Pop 0
            Unwind}
      
   5) VStack:[]
      Stack:[7: Ind 24 (2)]
      
      Dump:[<{}, S:[], V:[]>]
      
      Code:{Pop 0
            Unwind}
      
   6) VStack:[]
      Stack:[7: Ind 24 (2)]
      
      Dump:[<{}, S:[], V:[]>]
      
      Code:{Unwind}
      
   7) VStack:[]
      Stack:[24: 2]
      
      Dump:[<{}, S:[], V:[]>]
      
      Code:{Unwind}
      


Steps taken:7
Heap size:24